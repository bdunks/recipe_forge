defmodule RecipeForge.Recipes do
  @moduledoc """
  The Recipes context.
  """

  import Ecto.Query, warn: false

  alias RecipeForge.Categories
  alias RecipeForge.Ingredients
  alias RecipeForge.Repo

  alias RecipeForge.Recipes.Recipe

  @duplicate_ingredients_error "cannot contain duplicate ingredients"
  @default_ai_category "AI_Generated"
  @instruction_separator "\n"

  @doc """
  Returns the default AI category name.
  """
  def default_ai_category, do: @default_ai_category

  @doc """
  Returns the list of recipes.
  """
  def list_recipes do
    Repo.all(Recipe)
    |> Repo.preload([:categories, recipe_ingredients: :ingredient])
  end

  @doc """
  Returns the list of recipes filtered by category.
  If category_id is nil, returns all recipes.
  """
  def list_recipes_by_category(nil) do
    list_recipes()
  end

  def list_recipes_by_category(category_id) do
    # Convert string UUID to binary if needed
    binary_category_id =
      case category_id do
        id when is_binary(id) and byte_size(id) == 36 -> Ecto.UUID.dump!(id)
        id -> id
      end

    from(r in Recipe,
      join: rc in "recipe_categories",
      on: rc.recipe_id == r.id,
      where: rc.category_id == ^binary_category_id,
      preload: [:categories, recipe_ingredients: :ingredient]
    )
    |> Repo.all()
  end

  @doc """
  Searches recipes by name, description, category, or ingredient using database queries.
  Returns an empty list for empty query strings.
  """
  def search_recipes(""), do: []

  def search_recipes(query) when is_binary(query) do
    query_pattern = "%#{String.downcase(query)}%"

    from(r in Recipe,
      left_join: c in assoc(r, :categories),
      left_join: ri in assoc(r, :recipe_ingredients),
      left_join: i in assoc(ri, :ingredient),
      where:
        ilike(r.name, ^query_pattern) or
          ilike(r.description, ^query_pattern) or
          ilike(c.name, ^query_pattern) or
          ilike(i.name, ^query_pattern),
      distinct: r.id,
      order_by: [asc: r.id],
      preload: [:categories, recipe_ingredients: :ingredient]
    )
    |> Repo.all()
  end

  @doc """
  Gets a single recipe.

  Raises `Ecto.NoResultsError` if the Recipe does not exist.
  """
  def get_recipe!(id) do
    Repo.get!(Recipe, id)
    |> Repo.preload([:categories, recipe_ingredients: :ingredient])
  end

  @doc """
  Creates a recipe.
  """
  def create_recipe(attrs \\ %{}) do
    execute_recipe_transaction(%Recipe{}, attrs, :insert)
  end

  # @spec update_recipe(%RecipeForge.Recipes.Recipe{optional(any()) => any()}, any()) :: any()
  @doc """
  Updates a recipe.
  """

  def update_recipe(%Recipe{} = recipe, attrs) do
    execute_recipe_transaction(recipe, attrs, :update)
  end

  @doc """
  Deletes a recipe.
  """
  def delete_recipe(%Recipe{} = recipe) do
    Repo.delete(recipe)
  end

  @doc """
  Returns an `%Ecto.Changeset{}` for tracking recipe changes.
  """
  def change_recipe(%Recipe{} = recipe, attrs \\ %{}) do
    Recipe.changeset(recipe, attrs)
  end

  @doc """
  Handles creating a recipe from the map generated by the AI.

  This involves finding/creating categories and ingredients, and structuring
  the attributes for `create_recipe/1`.
  """
  def create_recipe_from_ai(ai_data) do
    recipe_attrs =
      %{
        "name" => Map.get(ai_data, :name),
        "description" => Map.get(ai_data, :description),
        # The recipe changeset expects a single string for instructions
        "instructions" =>
          case Map.get(ai_data, :instructions, []) do
            list when is_list(list) -> Enum.join(list, @instruction_separator)
            string when is_binary(string) -> string
            _ -> ""
          end,
        "prep_time" => Map.get(ai_data, :prep_time),
        "cook_time" => Map.get(ai_data, :cook_time),
        "servings" => Map.get(ai_data, :servings),
        "yield_description" => Map.get(ai_data, :yield_description),
        "image_url" => Map.get(ai_data, :image_url),
        "notes" => Map.get(ai_data, :notes),
        "nutrition" => Map.get(ai_data, :nutrition),
        "category_tags" => Map.get(ai_data, :category_name, @default_ai_category),
        "recipe_ingredients" =>
          (ai_data[:ingredients] || [])
          # Start at 0 for display_order
          |> Enum.with_index()
          |> Enum.into(%{}, fn {ing_data, index} ->
            {Integer.to_string(index),
             %{
               "ingredient_name" => Map.get(ing_data, :name),
               "quantity" => Map.get(ing_data, :quantity),
               "unit" => Map.get(ing_data, :unit),
               "notes" => Map.get(ing_data, :notes),
               # Index starting at 0
               "display_order" => index
             }}
          end)
      }

    create_recipe(recipe_attrs)
  end

  ##################################################################
  # Private Helpers
  ##################################################################

  defp execute_recipe_transaction(recipe, attrs, action) do
    repo_action = if action == :insert, do: &Repo.insert/1, else: &Repo.update/1

    case Repo.transaction(fn ->
           case prepare_associations(attrs) do
             {:ok, prepared_attrs} ->
               recipe
               |> Recipe.changeset(prepared_attrs, action: :save)
               |> repo_action.()

             {:error, :duplicate_ingredients} ->
               # Create proper error changeset and rollback
               changeset = Recipe.changeset(recipe, attrs, action: :save)

               error_changeset = %{
                 changeset
                 | action: action,
                   valid?: false,
                   errors: [recipe_ingredients: {@duplicate_ingredients_error, []}]
               }

               Repo.rollback(error_changeset)

             {:error, reason} ->
               Repo.rollback(reason)
           end
         end) do
      {:ok, result} ->
        # Transaction completed successfully
        result

      {:error, changeset} when is_struct(changeset, Ecto.Changeset) ->
        # Rollback returned a changeset (our duplicate ingredients error)
        {:error, changeset}

      {:error, _reason} ->
        # Transaction was manually rolled back for other reasons
        changeset = Recipe.changeset(recipe, attrs, action: :save)
        {:error, %{changeset | action: action, valid?: false}}
    end
  end

  defp prepare_associations(attrs) do
    with {:ok, categories} <- Categories.find_or_create_from_names(attrs["category_tags"]),
         :ok <- validate_no_duplicate_ingredient_names(attrs["recipe_ingredients"]),
         {:ok, recipe_ingredients_attrs} <-
           find_or_create_ingredients_for_recipe(attrs["recipe_ingredients"]) do
      final_attrs =
        attrs
        |> Map.put("categories", categories)
        |> Map.put("recipe_ingredients", recipe_ingredients_attrs)

      {:ok, final_attrs}
    end
  end

  defp find_or_create_ingredients_for_recipe(ingredients_attrs) when is_map(ingredients_attrs) do
    # Process map directly, maintaining order by sorting keys
    sorted_ingredients =
      ingredients_attrs
      |> Enum.sort_by(fn {index, _} -> String.to_integer(index) end)

    # Process each ingredient while preserving map structure
    Enum.reduce_while(sorted_ingredients, {:ok, %{}}, fn {index, i_attrs}, {:ok, acc} ->
      # Skip ingredient creation if marked for destruction
      if i_attrs["_destroy"] == "true" do
        {:cont, {:ok, Map.put(acc, index, i_attrs)}}
      else
        case Ingredients.find_or_create_by_name(i_attrs["ingredient_name"]) do
          {:ok, ingredient} ->
            final_attrs = Map.put(i_attrs, "ingredient_id", ingredient.id)
            {:cont, {:ok, Map.put(acc, index, final_attrs)}}

          {:error, reason} ->
            {:halt, {:error, reason}}
        end
      end
    end)
  end

  # Handle empty/nil case
  defp find_or_create_ingredients_for_recipe(ingredients_attrs),
    do: {:ok, ingredients_attrs || %{}}

  defp validate_no_duplicate_ingredient_names(ingredients_attrs) when is_map(ingredients_attrs) do
    # Extract ingredient names from all non-destroyed ingredients
    ingredient_names =
      ingredients_attrs
      |> Enum.reject(fn {_key, params} -> params["_destroy"] == "true" end)
      |> Enum.map(fn {_key, params} ->
        String.trim(params["ingredient_name"] || "") |> String.downcase()
      end)
      |> Enum.reject(fn name -> name == "" end)

    # Check for duplicates
    unique_names = Enum.uniq(ingredient_names)

    if length(ingredient_names) != length(unique_names) do
      # Return the proper error tuple directly
      {:error, :duplicate_ingredients}
    else
      :ok
    end
  end

  defp validate_no_duplicate_ingredient_names(_), do: :ok

  @doc """
  Returns the list of favorite recipes.
  """
  def list_favorite_recipes do
    from(r in Recipe,
      where: r.is_favorite == true,
      preload: [:categories, recipe_ingredients: :ingredient]
    )
    |> Repo.all()
  end

  @doc """
  Toggles the favorite status of a recipe.
  """
  def toggle_favorite(recipe) do
    with {:ok, updated_recipe} <-
           recipe
           |> Recipe.changeset(%{is_favorite: !recipe.is_favorite})
           |> Repo.update() do
      {:ok, Repo.preload(updated_recipe, [:categories, recipe_ingredients: :ingredient])}
    end
  end

  @doc """
  Returns the total number of recipes.
  """
  def count_recipes do
    Repo.aggregate(Recipe, :count, :id)
  end
end
