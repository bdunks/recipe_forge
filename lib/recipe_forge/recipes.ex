defmodule RecipeForge.Recipes do
  @moduledoc """
  The Recipes context.
  """

  import Ecto.Query, warn: false

  alias RecipeForge.Categories
  alias RecipeForge.Ingredients
  alias RecipeForge.Repo

  alias RecipeForge.Recipes.Recipe

  @doc """
  Returns the list of recipes.
  """
  def list_recipes do
    Repo.all(Recipe)
  end

  @doc """
  Gets a single recipe.

  Raises `Ecto.NoResultsError` if the Recipe does not exist.
  """
  def get_recipe!(id) do
    Recipe
    |> Repo.get!(id)
    |> Repo.preload([:categories, recipe_ingredients: :ingredient])
  end

  @doc """
  Builds a recipe changeset for validation, resolving associations without side-effects.
  """
  def build_recipe_changeset(%Recipe{} = recipe, attrs) do
    # These helpers return raw data (list/map of structs)
    categories = Categories.build_from_form_attrs(attrs["category_tags"])
    recipe_ingredients = Ingredients.build_from_form_attrs(attrs["recipe_ingredients"])

    final_attrs =
      attrs
      |> Map.put("categories", categories)
      |> Map.put("recipe_ingredients", recipe_ingredients)

    Recipe.changeset(recipe, final_attrs)
  end

  @doc """
  Creates a recipe.
  """
  def create_recipe(attrs \\ %{}) do
    Repo.transaction(fn ->
      with {:ok, categories} <-
             Categories.find_or_create_from_form_attrs(attrs["category_tags"]),
           {:ok, recipe_ingredients} <-
             Ingredients.find_or_create_from_form_attrs(attrs["recipe_ingredients"]) do
        final_attrs =
          attrs
          |> Map.put("categories", categories)
          |> Map.put("recipe_ingredients", recipe_ingredients)

        %Recipe{}
        |> Recipe.changeset(final_attrs)
        |> Repo.insert()
      end
    end)
    |> case do
      {:ok, result} -> result
      {:error, reason} -> reason
    end
  end

  # @spec update_recipe(%RecipeForge.Recipes.Recipe{optional(any()) => any()}, any()) :: any()
  @doc """
  Updates a recipe.
  """

  def update_recipe(%Recipe{} = recipe, attrs) do
    Repo.transaction(fn ->
      with {:ok, categories} <-
             Categories.find_or_create_from_form_attrs(attrs["category_tags"]),
           {:ok, recipe_ingredients} <-
             Ingredients.find_or_create_from_form_attrs(attrs["recipe_ingredients"]) do
        final_attrs =
          attrs
          |> Map.put("categories", categories)
          |> Map.put("recipe_ingredients", recipe_ingredients)

        recipe
        |> Recipe.changeset(final_attrs)
        |> Repo.update()
      end
    end)
  end

  @doc """
  Deletes a recipe.
  """
  def delete_recipe(%Recipe{} = recipe) do
    Repo.delete(recipe)
  end

  @doc """
  Returns an `%Ecto.Changeset{}` for tracking recipe changes.
  """
  def change_recipe(%Recipe{} = recipe, attrs \\ %{}) do
    Recipe.changeset(recipe, attrs)
  end

  @doc """
  Handles creating a recipe from the map generated by the AI.

  This involves finding/creating categories and ingredients, and structuring
  the attributes for `create_recipe/1`.
  """
  def create_recipe_from_ai(ai_data) do
    # 1. Prepare Category: Convert the AI-generated category name into the space-separated tag format.
    category_tags =
      ai_data
      |> Map.get(:category_name, "AI Generated")

    # 2. Transform AI ingredients data into the format our context expects.
    # AI format: `[%{name: "flour", ...}]`
    # Context format: `[%{"ingredient_name" => "flour", ...}]`
    recipe_ingredients_attrs =
      (ai_data[:ingredients] || [])
      |> Enum.with_index()
      |> Enum.into(%{}, fn {ing_data, index} ->
        {index,
         %{
           "ingredient_name" => Map.get(ing_data, :name),
           "quantity" => Map.get(ing_data, :quantity),
           "unit" => Map.get(ing_data, :unit),
           "notes" => Map.get(ing_data, :notes),
           "display_order" => index + 1
         }}
      end)

    # 3. Assemble the final attributes map for `create_recipe`.
    recipe_attrs =
      %{
        "name" => Map.get(ai_data, :name),
        "description" => Map.get(ai_data, :description),
        # The recipe changeset expects a single string for instructions
        "instructions" => Map.get(ai_data, :instructions, []) |> Enum.join("\n"),
        "prep_time" => Map.get(ai_data, :prep_time),
        "cook_time" => Map.get(ai_data, :cook_time),
        "servings" => Map.get(ai_data, :servings),
        "yield_description" => Map.get(ai_data, :yield_description),
        "image_url" => Map.get(ai_data, :image_url),
        "notes" => Map.get(ai_data, :notes),
        "nutrition" => Map.get(ai_data, :nutrition),
        "category_tags" => category_tags,
        "recipe_ingredients" => recipe_ingredients_attrs
      }

    # 4. Call the standard `create_recipe` function with the prepared attributes.
    create_recipe(recipe_attrs)
  end
end
